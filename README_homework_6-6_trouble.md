# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по 
[администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
```commandline
Запрос текущих запущенных операций получение opid
db.currentOp()
Убить операцию на основе opid
db.killOp(30318806)
```
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Ответы: Варианты по долгим запросам:
- выполнять в фоновом режиме чтобы они не блокировали остальные;
- недостаток индексов для поисков, провести анализ запросов Mongostat, выявить какие
необходимо добавить индексы для поиска;
- использовать профилировщик и оптимизатор производительности запросов Mongo;

## Задача 2

Перед выполнением задания познакомьтесь с документацией по 
[Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

Ответы:
- Стратегия истечения срока действия Redis и механизм устранения памяти
"Периодическое удаление + ленивое удаление" В настоящее время Redis предоставляет в общей сложности 8 стратегий удаления памяти, 
включая два новых режима LFU после Redis 4.0: volatile-lfu и allkeys-lfu.
- однопоточная система и длительные запросы блокируют предыдущие, оптимизировать запросы,
можно использовать распределенную архитектуру - разделение чтения и записи, фрагментация данных

 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по 
[Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?
Ответы:
- потеря соединения при выполнении запрос SELECT на выборку данных
- причины:
- большой объем данных длительные запросы и установленные параметры конфигурации не поддерживаются;
- большие объекты данных поскольку гис система;
- территориальная удаленность пользователей и сетевые задержки при запросах;
- нужно оптимизировать запросы джойны по таблицам;
- увеличить параметры на сервере  net_read_timeout или connect_timeout values.
- увеличить параметры на клиенте Python script `con.query('SET GLOBAL connect_timeout=6000')`

Какие пути решения данной проблемы вы можете предложить?

Существует несколько вероятных причин появления этого сообщения об ошибке.
1. Обычно это указывает на проблемы с сетевым подключением, и вам следует проверить состояние вашей сети, 
если эта ошибка возникает часто. 
2. Иногда форма “во время запроса” возникает, когда миллионы строк отправляются 
как часть одного или нескольких запросов. Если вы знаете, что это происходит, 
вам следует попробовать увеличить `net_read_timeout` с значения по умолчанию 30 секунд до 60 секунд или дольше, 
достаточного для завершения передачи данных.
3. Возможно это происходит при первоначальном соединении с сервером. 
В этом случае, если ваше значение `connect_timeout` установлено всего на несколько секунд, 
вы можете решить проблему, увеличив его до десяти секунд, возможно, больше, 
если у вас очень большое расстояние или медленное соединение. 
Это можно проверить через запрос глобального статуса, используя `SHOW GLOBAL STATUS LIKE 'Aborted_connects'`. 
Он увеличивается на единицу при каждой первоначальной попытке подключения, которую прерывает сервер. 
Вы можете увидеть “чтение пакета авторизации” как часть сообщения об ошибке; если да, то это также говорит о том, 
что это именно то решение, которое вам нужно.
4. Если причина не является ни одной из только что описанных, возможно, у вас возникла проблема 
со значениями больших двоичных объектов, которые больше `max_allowed_packet`, 
что может вызвать эту ошибку у некоторых клиентов. Иногда вы можете увидеть ошибку `ER_NET_PACKET_TOO_LARGE`, 
и это подтверждает, что вам необходимо увеличить `max_allowed_packet`.


## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors]
(https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Ответ:

Работает Out-Of-Memory Killer.

Процессы потребляют много памяти и Linux их завершает. предлагает 2 пути решения: 
обрушить всю систему или завершить процесс (приложение), который съедает память. Лучше, конечно, 
завершить процесс и спасти ОС от аварийного завершения. В двух словах, 
Out-Of-Memory Killer — это процесс, который завершает приложение, чтобы спасти ядро от сбоя. 
Он жертвует приложением, чтобы сохранить работу ОС.

Как бы вы решили данную проблему?

- Процессы, связанные с привилегированным пользователем, имеют более низкую оценку и меньше шансов на принудительное завершение.

- Если вы совсем не хотите, чтобы OOM-Killer завершил процесс, есть еще один параметр ядра: oom_score_adj. 
Добавьте большое отрицательное значение, чтобы снизить шансы на завершение дорогого вам процесса.

- OOM-Killer можно не только включать и выключать. Linux может зарезервировать для процессов больше памяти, чем есть, но не выделять ее по факту, и этим поведением управляет параметр ядра Linux. За это отвечает переменная vm.overcommit_memory.
Для нее можно указывать следующие значения:

0: ядро само решает, стоит ли резервировать слишком много памяти. Это значение по умолчанию в большинстве версий Linux.
1: ядро всегда будет резервировать лишнюю память. Это рискованно, ведь память может закончиться, потому что, скорее всего, однажды процессы затребуют положенное.
2: ядро не будет резервировать больше памяти, чем указано в параметре overcommit_ratio.

Чтобы не приходилось использовать OOM-Killer для завершения PostgreSQL, можно установить для vm.overcommit_memory значение 2. 
Это не гарантирует, что OOM-Killer не придется вмешиваться, 
но снизит вероятность принудительного завершения процесса PostgreSQL.
---